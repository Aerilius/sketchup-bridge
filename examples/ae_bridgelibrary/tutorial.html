<html>
  <head>
    <title>SketchUp Bridge Tutorial</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <script type="text/javascript" src="./bridge.js"></script>
    <style>
      body {
        /* Override the too serify default Times font.*/
        font-family: Calibri, Helvetica;
      }
      textarea {
        width: 100%;
        resize: vertical;
      }
      table {
        width: 100%;
        background: white;
      }
      table, td {
        border: 1px lightGray solid;
      }
      pre {
        white-space: pre-wrap;
      }
      code.javascript {
        color: #2222aa;
      }
      code.javascript:before {
        display: block;
        font-size: 75%;
        color: gray;
        content: 'JavaScript';
      }
      code.ruby {
        color: #aa2222;
      }
      code.ruby:before {
        display: block;
        font-size: 75%;
        color: gray;
        content: 'Ruby';
      }
      tt {
        font-size: 120%;
      }
      .example {
        background: #fffadd;
        padding: 1em;
      }
      hr {
        border: 1px lightGray solid;
      }
    </style>
    <script>
function isSketchUp () {
  return navigator.userAgent.search('SketchUp') !== -1;
}
// This is a mock for running the tutorial in a browser.
if (!isSketchUp()) {
  var Bridge = {
    get: function (callbackName, arg1, arg2) {
      return new Promise(function (resolve, reject) {
        switch (callbackName) {
          case 'settings':
            resolve({ 'size': 12.5 });
            break;
          case 'compute_result1':
            try {
              if (arg2 == 0) {
                throw Error('ZeroDivisionError: divided by 0');
              }
              resolve(arg1 / arg2);
            } catch (e) {
              reject(e);
            }
            break;
          case 'compute_result2':
            try {
              if (arg1 < 0) {
                throw Error('Math::DomainError: Numerical argument is out of domain - "sqrt"');
              }
              resolve(Math.sqrt(arg1));
            } catch (e) {
              reject(e);
            }
            break;
          case 'compute_asynchronously':
            window.setTimeout(function () {
              resolve(42);
            }, 3000);
            break;
        }
      });
    },
    call: function (callbackName) {
      switch (callbackName) {
        case 'select_pushpull':
          console.log('(selected Pushpull tool)');
          break;
         case 'ruby_to_javascript1':
           entitySelected('ComponentInstance#1', {'lenx': 71.0, 'leny': 32.5, 'lenz': 39.5});
           break;
         case 'ruby_to_javascript2':
           syncToServer('ComponentInstance#1', {'lenx': 71.0, 'leny': 32.5, 'lenz': 39.5}).then(function (response) {
              alert(response['responseText']);
            }, function (response) {
              alert(response['statusText']);
           });
           break;
      }
    }
  };
}
    </script>
  </head>
  <body>
    <section>
      <h1>Example usage of Bridge</h1>
      <p>Bridge is a bidirectional API for SketchUp's <tt>HtmlDialog</tt> and <tt>WebDialog</tt>.
      It aims to encourage good programming practices:</p>
      <ul>
        <li>Abstract repeated patterns into <b>functions</b> (e.g. not directly calling <tt>window.location = 'skp:callbackname'</tt>) helps maintaining code and allows to replace the implementation (like this library) at any time with little effort. (<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="blank">DRY</a>)</li>
        <li>Using proven <b>libraries</b> for handling <b>low-level operations</b> (like string concatenation, serialization of arguments and escaping). The less code you write on your own, the less errors you make (well, there could be errors in the libraries). Write as little code as necessary.</li>
        <li>Keeping <b>related code together</b>. Your code becomes more readable if an action (request to Ruby) and follow-up action (receiving result from Ruby) are not in different places or functions.</li>
        <li>Supporting <b>asynchronicity</b> of HtmlDialog (and WebDialog on macOS). Invoking a callback from JavaScript (<tt>sketchup.callbackname()</tt> or <tt>window.location = 'skp:callbackname'</tt>) runs already the next line of JavaScript before the Ruby callback is completed.</li>
      </ul>
      <p>Bridge is based on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="blank">promises</a>. Promises help us to write clean asynchronous code as easily as synchronous code and keep subsequent operations together. Promises are proxies for values that are initially unknown. You provide a callback that is called once that the value is known, and optionally a callback for when retrieving the value failed. A promise supports two methods:
      </p>
      <ul>
        <li><tt>then(successCallback)</tt> &emsp; This callback function is called when the promise succeeds. It receives the result object as parameter.</li>
        <li><tt>catch(errorCallback)</tt> &emsp; The callback function is called when the previous promise fails. It receives the error object as parameter.</li>
        <li><tt>then(successCallback, errorCallback)</tt> &emsp; You can also provide both callbacks in a single function call.</li>
      </ul>
      <p>All of these methods themselves return a promise, so you can chain methods as if the code in the callbacks was sequential:
<pre><code>promise.then(callback1).then(callback2).then(callback3)</code></pre>
        or even:
<pre><code class="javascript">let result0 = await promise
let result1 = await callback1(result0)
let result2 = await callback2(result1)
let result3 = await callback2(result2)</code></pre>
        Without promises all these callbacks would be spread in different places and the sequential structure would not be obvious, which makes the code hard to understand and hard to maintain.</p>
      <p>(For a deeper introduction to the advantages of promises, see <a href="https://www.stephanboyer.com/post/107/fun-with-promises-in-javascript" target="blank">this blog post</a>.</p>
    </section>
    <section>
      <h2>Overview</h2>
      <ul style="list-style-type: none">
        <li>JavaScript:
          <ul style="list-style-type: none">
            <li><a href="#javascript-bridge-call"><tt>Bridge.call(callbackname, ...args) → void</tt></a></li>
            <li><a href="#javascript-bridge-get"><tt>Bridge.get(callbackname, ...args) → Promise</tt></a></li>
          </ul>
        </li>
        <li>Ruby:
          <ul style="list-style-type: none">
            <li><a href="#ruby-bridge-call"><tt>Bridge.call(callbackname, ...args) → nil</tt></a></li>
            <li><a href="#ruby-bridge-get"><tt>Bridge.get(callbackname, ...args) → Promise</tt></a></li>
          </ul>
        </li>
    </section>
    <section>
      <h2>JavaScript to Ruby</h2>
      <section>
        <h3>1.1 Bidirectional API &emsp; <tt>Bridge.get(callbackname, ...args) → Promise</tt><a id="javascript-bridge-get"></a></h2>
        <p>Send a request from the dialog to Ruby and receive the response.</p>
        <section>
          <h4>Initializing the dialog</h3>
          <p>Showing and loading the dialog is asynchronous. That means when the Ruby method <code>dialog.show</code> finishes, the dialog is not fully loaded, so you cannot immediately call <code>dialog.execute_script</code>. Instead of making your Ruby code push data to the dialog (not knowing whether the dialog is loaded successfully), make your dialog fetch data whenever it needs. That means the Ruby part is like a server, and the dialog is the client. Use the following pattern to initialize your dialog when the document is ready:</p>
<pre><code class="javascript">function initialize () {
  Bridge.get('settings').then(function (settings) {
    // Do something with the settings, initialize your app etc.
  }
}

// Register a handler for the event when the document has been loaded.
// If you use jQuery, you can use $(function () { }) instead.
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initialize);
} else {
  initialize();
}</code></pre>
          <div class="example">
            <div>
              <button id="button1_get_settings">Get settings</button>
            </div>
            <textarea id="textarea1_settings_result"></textarea>
            <script>
            var button1 = document.getElementById('button1_get_settings');
            var textarea1 = document.getElementById('textarea1_settings_result');
            button1.addEventListener('click', function (event) {
              textarea1.value = '';
              Bridge.get('settings').then(function (settings) {
                // The settings are an object, just like in Ruby, so we can use them in our app.
                // Only for the purpose of showing them in a textarea, we serialize them as a JSON string.
                textarea1.value = JSON.stringify(settings);
              });
            });
            </script>
          </div>
        </section>
        <section>
          <h4>Handling errors in callbacks</h3>
          <p>When an error happens, you may want to know about it. You can handle errors in Ruby or in JavaScript.</p>
<pre><code class="javascript">Bridge.get('compute_result1', argument1, argument2).then(function (result) {
  // Do something with the result
}, function (error) {
  // Do any kind of error handling, choose an alternative code path,
  // or display a friendly message to the user.
});</code></pre>
          <div class="example">
            <div>
              <input type="number" id="input21_compute_result1" value="4"/>
              <input type="number" id="input22_compute_result1" value="0"/>
              <button id="button2_compute_result1">Compute division</button>
            </div>
            <div>
              <label>Result:</label>
            </div>
            <textarea id="textarea2_compute_result1_result"></textarea>
            <div>
              <label>Error:</label>
            </div>
            <textarea id="textarea2_compute_result1_error"></textarea>
            <script>
            var input21 = document.getElementById('input21_compute_result1');
            var input22 = document.getElementById('input22_compute_result1');
            var button2 = document.getElementById('button2_compute_result1');
            var textarea2Result = document.getElementById('textarea2_compute_result1_result');
            var textarea2Error = document.getElementById('textarea2_compute_result1_error');
            button2.addEventListener('click', function (event) {
              var dividend = parseInt(input21.value);
              var divisor = parseInt(input22.value);
              textarea2Result.value = '';
              textarea2Error.value = '';
              Bridge.get('compute_result1', dividend, divisor).then(function (result) {
                textarea2Result.value = JSON.stringify(result);
              }, function (error) {
                textarea2Error.value = String(error) + (error.stack ? '\n' + error.stack : '') ;
              });
            });
            </script>
          </div>
          <hr/>
          <div class="example">
            <div>
              <input type="number" id="input3_compute_result2" value="-0.25"/>
              <button id="button3_compute_result2">Compute square root</button>
            </div>
            <div>
              <label>Result:</label>
            </div>
            <textarea id="textarea3_compute_result2_result"></textarea>
            <div>
              <label>Error:</label>
            </div>
            <textarea id="textarea3_compute_result2_error"></textarea>
            <script>
              var input3 = document.getElementById('input3_compute_result2');
              var button3 = document.getElementById('button3_compute_result2');
              var textarea3Result = document.getElementById('textarea3_compute_result2_result');
              var textarea3Error = document.getElementById('textarea3_compute_result2_error');
              button3.addEventListener('click', function (event) {
                var number = parseFloat(input3.value);
                textarea3Result.value = '';
                textarea3Error.value = '';
                Bridge.get('compute_result2', number).then(function (result) {
                  textarea3Result.value = JSON.stringify(result);
                }, function (error) {
                textarea3Error.value = String(error) + (error.stack ? '\n' + error.stack : '') ;
                });
              });
            </script>
          </div>
        </section>
        <section>
          <h4>Long-during computations</h3>
          <p>A promise does not need to return the result immediately. This allows you to continue your JavaScript code later, no matter how long it takes. For example your Ruby code may have called an external program, or downloaded a big file from the internet, or called a custom Select tool that resolves the promise only once that the user has picked an entity.</p>
<pre><code class="javascript">Bridge.get('compute_asynchronously').then(function (result) {
  // That may take long, but the callback is only called when the computation finished.
});</code></pre>
          <div class="example">
            <div>
              <button id="button4_compute_asynchronously">Compute</button>
            </div>
            <div>
              <label>Result:</label>
            </div>
            <textarea id="textarea4_compute_asynchronously"></textarea>
            <script>
              var button4 = document.getElementById('button4_compute_asynchronously');
              var textarea4 = document.getElementById('textarea4_compute_asynchronously');
              button4.addEventListener('click', function (event) {
                textarea4.value = 'Computing...';
                Bridge.get('compute_asynchronously').then(function (result) {
                  textarea4.value = JSON.stringify(result);
                });
              });
            </script>
          </div>
        </section>
      </section>
      <section>
        <h3>1.2 One way API &emsp; <tt>Bridge.call(callbackname, ...args) → void</tt><a id="javascript-bridge-call"></a></h2>
        <p>Sometimes you want to trigger some action, but don't receive a result. The method <tt>Bridge.call</tt> works the same way, but does not return a promise.</p>
<pre><code class="javascript">Bridge.call('select_pushpull');</code></pre>
        <div class="example">
          <button id="button5" onclick="Bridge.call('select_pushpull')">Action</button>
        </div>
      </section>
      <section>
        <h3>1.3 Using modern JavaScript</h2>
        <p>If you are tired of writing <tt>function</tt> and don't need to support WebDialogs, you can use modern JavaScript features like:</p>
        <ul>
          <li><b>Arrow functions</b>: A short function can be replaced by <tt>(arg) => expression</tt>. (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="blank">Reference</a>). You can then write: <br/><pre><code>Bridge.get('settings').then(settings => alert(settings))</code></pre></li>
          <li><b><tt>async</tt> and <tt>await</tt></b>: These new keywords allow to write code with promises sequentially. (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="blank">Reference</a>)</li>
        </ul>
<pre><code class="javascript">async function myAsyncFunction () {
  // As you know, Bridge.get returns a promise, not the result.
  let result1 = await Bridge.get('compute_result1', 4, 2);
  // The await keyword "converts" all subsequent code into a thenable that is 
  // only run when the promise is resolved. This is non-blocking!
  // Do something with result1. This can again be asynchronous!
  let result2 = await Bridge.get('compute_result2', result1);
  // Do something with result2. You can insert it into the output field,
  // or return it. The async keywords "converts" the return value into a promise.
  return result2;
};</code></pre>
        <div class="example">
          <small>(Note: This does not work in WebDialog/Internet Explorer.)</small>
          <div>
            <label>a = <input type="number" id="input61" value="4"/></label>
            <label>b = <input type="number" id="input62" value="2"/></label>
            <button id="button6">Compute sqrt(a / b)</button>
          </div>
          <div>
            <label>Result:</label>
          </div>
          <textarea id="textarea6_result"></textarea>
          <div>
            <label>Error:</label>
          </div>
          <textarea id="textarea6_error"></textarea>
          <script>
          async function myAsyncFunction (a, b) {
            var result1, result2;
            // As you know, Bridge.get returns a promise, not the result.
            result1 = await Bridge.get('compute_result1', a, b);
            // The await keyword "converts" all subsequent code into a thenable that is 
            // only run when the promise is resolved. This is non-blocking!
            // Do something with result1. This can again be asynchronous!
            result2 = await Bridge.get('compute_result2', result1);
            // Do something with result2. You can insert it into the output field,
            // or return it. The async keywords "converts" the return value into a promise.
            return result2;
          };
          var input61 = document.getElementById('input61');
          var input62 = document.getElementById('input62');
          var button6 = document.getElementById('button6');
          var textarea6Result = document.getElementById('textarea6_result');
          var textarea6Error = document.getElementById('textarea6_error');
          button6.addEventListener('click', function (event) {
            var a = parseInt(input61.value);
            var b = parseInt(input62.value);
            textarea6Result.value = '';
            textarea6Error.value = '';
            myAsyncFunction(a, b).then(function (result) {
              textarea6Result.value = JSON.stringify(result);
            }, function (error) {
              textarea6Error.value = String(error) + (error.stack ? '\n' + error.stack : '') ;
            });
          });
          </script>
        </div>
      </section>
    </section>
    <section>
      <h2>2 Ruby to JavaScript</h2>
      <p>In some cases, you want to push updates from Ruby to the dialog (when the dialog is loaded), for example when an observer was triggered because an entity was changed or the user selected a different entity. The same functions <tt>call</tt> and <tt>get</tt> work also on the bridge/dialog instance in Ruby. Using the <tt>Bridge.call</tt> method instead of <tt>execute_script</tt> ensures all arguments are properly encoded.</p>
      <section>
        <h3>2.1 Invoking JavaScript functions &emsp; <tt>dialog.call(javascript_function_name, ...arguments) → nil</tt><a id="ruby-bridge-call"></a></h3>
<pre><code class="ruby">entity_name = 'ComponentInstance#1'
attributes = {'lenx': 71.0, 'leny': 32.5, 'lenz': 39.5}
dialog.call('entitySelected', entity_name, attributes)</code></pre>
<pre><code class="javascript">function entitySelected (entityName, attributes) {
  // Do something with the parameters, like updating the user interface.
  // Alternatively to using parameters, you could fetch data from Ruby with Bridge.get.
}</code></pre>
        <div class="example">
          <div>
            <button id="button7">Entity changed</button>
          </div>
          <div>
            <label>Currently selected entity:</label>
          </div>
          <textarea id="textarea7_entity"></textarea>
          <div>
            <label>Which has these dynamic attributes:</label>
          </div>
          <table id="table7_attributes">
            <tr><td>&emsp;</td><td>&emsp;</td></tr>
          </table>
          <script>
          var button7 = document.getElementById('button7');
          var textarea7Entity = document.getElementById('textarea7_entity');
          var table7Attributes = document.getElementById('table7_attributes');
          function entitySelected (entityName, attributes) {
            textarea7Entity.value = entityName;
            while (table7Attributes.firstChild) {
              table7Attributes.removeChild(table7Attributes.firstChild);
            }
            for (var attribute in attributes) {
              if (attributes.hasOwnProperty(attribute)) {
                var value = attributes[attribute];
                var tr = document.createElement('tr');
                var tdAttribute = document.createElement('td');
                tdAttribute.appendChild(document.createTextNode(attribute));
                var tdValue = document.createElement('td');
                tdValue.appendChild(document.createTextNode(value));
                tr.appendChild(tdAttribute);
                tr.appendChild(tdValue);
                table7Attributes.appendChild(tr);
              }
            }
          }
          button7.addEventListener('click', function (event) {
            Bridge.call('ruby_to_javascript1');
          });
          </script>
        </div>
      </section>
      <section>
        <h3>2.2 Getting return values from JavaScript functions &emsp; <tt>dialog.get(javascript_function_name, ...arguments) → Bridge::Promise</tt><a id="ruby-bridge-get"></a></h3>
<pre><code class="ruby">changed_entity = 'ComponentInstance#1'
attributes = {'lenx': 71.0, 'leny': 32.5, 'lenz': 39.5}
dialog.get('syncToServer', changed_entity, attributes).then{ |server_response|
  puts(server_response['body'])
  # Do something with the result or continue in the plugin.
}.catch{
  puts(server_response['statusText'])
  # Handle the error.
}</code></pre>
<pre><code class="javascript">function syncToServer (entityName, attributes) {
  // Do something with the parameters, like sending a request to a remote server.
  // Return the result or a promise that will resolve later to the result.
  // Example using jQuery:
  return new Promise(function(resolve, reject) {
    $.ajax({
      url: 'www.example.com/app/synchronize-model',
      method: 'POST',
      data: {action: 'update', 'entity': entityName, 'attributes': attributes}
    }).done(resolve).fail(reject);
  });
}</code></pre>
        <div class="example">
          <div>
            <button id="button8">Entity changed</button>
          </div>
          <script>
          var button8 = document.getElementById('button8');
          var textarea8Result = document.getElementById('textarea8_result');
          function syncToServer (entityName, attributes) {
            return new Promise(function (resolve, reject) {
              window.setTimeout(function () {
                if (Math.random() > 0.5) {
                  resolve({
                    status: 200,
                    statusText: 'OK',
                    responseText: 'Model was successfully synced with the server.'
                  });
                } else {
                  reject({
                    status: 503,
                    statusText: 'Service Unavailable',
                    responseText: 'The server is currently unavailable.'
                  });
                }
              }, 1000);
            });
          }
          button8.addEventListener('click', function (event) {
            Bridge.call('ruby_to_javascript2');
          });
          </script>
        </div>
      </section>
    </section>
  </body>
</html>
